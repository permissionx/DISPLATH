<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASIM</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --primary-color: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #a5b4fc;
            --secondary-color: #06b6d4;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --dark-color: #1f2937;
            --light-color: #f8fafc;
            --border-color: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --bg-primary: #ffffff;
            --bg-secondary: #f1f5f9;
            --bg-tertiary: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .container {
            max-width: 2200px;
            margin: 0 auto;
            background: var(--bg-primary);
            padding: 24px;
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(10px);
            min-height: calc(100vh - 40px);
        }
        
        h1 {
            color: var(--primary-color);
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 12px;
            margin-top: 0;
            text-align: left;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2 {
            color: var(--text-primary);
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        h2::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 2px;
        }
        
        .mode-selector {
            margin-bottom: 32px;
            padding: 4px;
            background: var(--bg-secondary);
            border-radius: 12px;
            display: inline-flex;
            border: 1px solid var(--border-color);
        }
        
        .mode-selector label {
            margin: 0;
            padding: 8px 20px;
            font-weight: 500;
            font-size: 14px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }
        
        .mode-selector label:has(input:checked) {
            background: var(--primary-color);
            color: white;
            box-shadow: var(--shadow-sm);
        }
        
        .mode-selector input[type="radio"] {
            display: none;
        }
        .control-panel {
            display: grid;
            grid-template-columns: 1.618fr 1fr; /* Golden ratio */
            gap: 32px;
            margin-bottom: 32px;
        }
        
        .section {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            padding: 32px;
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s ease;
            min-height: 400px;
        }
        
        .section:hover {
            box-shadow: var(--shadow-md);
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .left-column {
            /* Left column will contain all inputs */
            padding: 0;
            border: none;
            background: transparent;
            box-shadow: none;
        }
        
        .right-column {
            /* Right column will contain outputs and controls */
            padding: 0;
            border: none;
            background: transparent;
            box-shadow: none;
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: sticky;
            top: 20px;
            height: fit-content;
            max-height: calc(100vh - 80px);
            overflow: visible;
        }
        
        .input-section {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s ease;
            margin-bottom: 20px;
        }
        
        .input-section:hover {
            box-shadow: var(--shadow-md);
        }
        
        .output-section {
            background: var(--bg-primary);
            border: none;
            padding: 20px;
            border-radius: 12px;
            box-shadow: none;
            transition: all 0.2s ease;
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        
        .control-section {
            background: var(--bg-primary);
            border: none;
            padding: 24px;
            border-radius: 12px;
            box-shadow: none;
            transition: all 0.2s ease;
        }
        
        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        select, input, textarea {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s ease;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        input[type="number"] {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 500;
            font-size: 14px;
        }
        
        select:focus, input:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px var(--primary-light);
        }
        
        input[type="checkbox"], input[type="radio"] {
            width: auto;
            margin-right: 8px;
            accent-color: var(--primary-color);
        }
        
        textarea {
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            min-height: 100px;
            resize: vertical;
            line-height: 1.5;
        }
        
        button {
            background: var(--primary-color);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-right: 12px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
            font-family: inherit;
        }
        
        button:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .stop-button {
            background: var(--danger-color);
        }
        
        .stop-button:hover:not(:disabled) {
            background: #dc2626;
        }
        
        .preview-button {
            background: var(--secondary-color);
        }
        
        .preview-button:hover:not(:disabled) {
            background: #0891b2;
        }
        
        .add-button {
            background: var(--success-color);
            font-size: 13px;
            padding: 8px 16px;
            margin: 4px 4px 4px 0;
        }
        
        .add-button:hover {
            background: #059669;
        }
        
        .remove-button {
            background: var(--danger-color);
            font-size: 13px;
            padding: 6px 12px;
            margin: 4px 0;
        }
        
        .remove-button:hover {
            background: #dc2626;
        }
        
        .template-button {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }
        
        .template-button:hover {
            background: #0891b2;
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        #output {
            background: var(--dark-color);
            color: #e2e8f0;
            padding: 16px;
            border-radius: 12px;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 12px;
            line-height: 1.5;
            min-height: 150px;
            max-height: 320px;
            overflow-y: auto;
            flex: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
            border: 1px solid #374151;
            box-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.1);
        }
        
        .output-line {
            margin: 3px 0;
            padding: 2px 0;
        }
        
        .error {
            color: #fca5a5;
            background: rgba(239, 68, 68, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            border-left: 3px solid var(--danger-color);
        }
        
        .success {
            color: #86efac;
            background: rgba(16, 185, 129, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            border-left: 3px solid var(--success-color);
        }
        .row {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .row input {
            flex: 1;
        }
        
        .advanced-params {
            margin-top: 32px;
            padding-top: 24px;
            border-top: 1px solid var(--border-color);
        }
        
        .hidden {
            display: none;
        }
        
        #script-preview {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 13px;
            line-height: 1.5;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 24px;
            color: var(--text-primary);
            box-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);
        }
        .element-row {
            display: flex;
            gap: 16px;
            align-items: center;
            margin-bottom: 12px;
            padding: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            transition: all 0.2s ease;
            flex-wrap: wrap;
        }
        
        .element-row:hover {
            background: #e2e8f0;
        }
        
        .element-row input, .element-row select {
            margin-bottom: 0;
        }
        
        .crystal-elements {
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: 8px;
            background: var(--bg-secondary);
            margin-bottom: 20px;
            min-height: 200px;
        }
        
        .small-input {
            width: 100px !important;
        }
        
        .medium-input {
            width: 140px !important;
        }
        
        .matrix-input {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .matrix-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .matrix-row input {
            flex: 1;
            margin-bottom: 0;
            text-align: center;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 600;
            font-size: 16px;
            padding: 14px 12px;
        }
        
        .matrix-row input:disabled {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: not-allowed;
            font-weight: 400;
        }
        
        .basis-container {
            border: 1px solid var(--border-color);
            padding: 16px;
            border-radius: 8px;
            background: var(--bg-secondary);
            margin-bottom: 16px;
        }
        
        .basis-row {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 12px;
            padding: 16px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .basis-row:hover {
            background: #f8fafc;
        }
        
        .basis-row input {
            margin-bottom: 0;
        }
        
        .coord-input {
            width: 120px !important;
        }
        
        .type-input {
            width: 80px !important;
        }
        
        .coord-row {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .coord-row label {
            margin-bottom: 0;
            width: 20px;
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
        }
        
        .range-inputs {
            margin-bottom: 16px;
        }
        
        .range-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
        }
        
        .range-row label {
            margin-bottom: 0;
            width: 20px;
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
        }
        
        .range-row span {
            margin: 0 8px;
            color: var(--text-secondary);
            font-size: 12px;
        }
        
        .range-row input {
            width: 80px;
            margin-bottom: 0;
        }
        
        .periodic-row {
            display: flex;
            gap: 20px;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .periodic-row label {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            cursor: pointer;
            height: 100%;
        }
        
        .ion-params {
            margin-bottom: 20px;
        }
        
        .ion-row {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .ion-row label {
            margin-bottom: 0;
            white-space: nowrap;
            font-weight: 500;
            display: flex;
            align-items: center;
        }
        
        .mode-row {
            display: flex;
            gap: 24px;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .mode-row label {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            cursor: pointer;
            height: 100%;
        }
        
        .button-panel {
            margin: 32px 0;
            padding: 24px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
        }
        
        /* Script Preview Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background-color: var(--bg-primary);
            margin: 2% auto;
            padding: 0;
            border: 1px solid var(--border-color);
            border-radius: 16px;
            width: 80%;
            max-width: 1200px;
            max-height: 90vh;
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
        }
        
        .modal-header {
            padding: 24px 32px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 16px 16px 0 0;
        }
        
        .modal-header h2 {
            margin: 0;
            color: white;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .modal-header h2::before {
            display: none;
        }
        
        .close {
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }
        
        .close:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .modal-body {
            padding: 32px;
            overflow-y: auto;
            flex: 1;
        }
        
        #script-preview-modal {
            font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            background: var(--dark-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 0;
            white-space: pre;
            word-wrap: break-word;
            color: #e2e8f0;
            max-height: 60vh;
            overflow-y: auto;
            overflow-x: auto;
            tab-size: 4;
        }
        
        /* 3D Crystal Viewer */
        .crystal-viewer-section {
            background: var(--bg-primary);
            border: none;
            padding: 24px;
            border-radius: 12px;
            box-shadow: none;
            transition: all 0.2s ease;
            height: auto;
        }
        
        #crystal-viewer {
            width: 100%;
            aspect-ratio: 1 / 1;  /* Make it square */
            max-height: 400px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: #2a2a2a;  /* Dark gray instead of gradient */
            position: relative;
            overflow: hidden;
        }
        
        .viewer-info {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: 'Inter', sans-serif;
            z-index: 10;
        }
        
        .viewer-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            font-style: italic;
            text-align: center;
            line-height: 1.4;
            padding: 20px;
        }
        
        .viewer-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .viewer-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        /* Path autocomplete styles */
        .path-autocomplete-container {
            position: relative;
            flex: 1;
            min-width: 300px;
        }
        
        .path-autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            display: none;
        }
        
        .path-autocomplete-dropdown.show {
            display: block;
        }
        
        .path-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .path-suggestion:hover,
        .path-suggestion.selected {
            background: var(--bg-secondary);
        }
        
        .path-suggestion .icon {
            color: var(--primary-color);
            font-size: 16px;
            width: 20px;
            text-align: center;
        }
        
        .path-suggestion .name {
            flex: 1;
        }
        
        .path-suggestion.directory .icon::before {
            content: '📁';
        }
        
        /* Working directory status styles */
        .working-directory-status {
            margin-top: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }
        
        .working-directory-status.show {
            display: flex;
        }
        
        .working-directory-status.success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #059669;
        }
        
        .working-directory-status.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #dc2626;
        }
        
        .status-icon {
            font-size: 18px;
            display: flex;
            align-items: center;
        }
        
        .status-text {
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .confirm-button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 4px rgba(99, 102, 241, 0.2);
        }
        
        .confirm-button:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(99, 102, 241, 0.3);
        }
        
        .confirm-button:active {
            transform: translateY(0);
        }
        
        .confirm-button:disabled {
            background: var(--text-secondary);
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .working-directory-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .working-directory-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .working-directory-badge {
            background: var(--primary-light);
            color: var(--primary-dark);
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            display: none;
        }
        
        .working-directory-badge.show {
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="container">
        
        <!-- Parameter Input Mode -->
        <div id="parameter-mode">
            <div class="control-panel">
                <!-- Left Column - All Inputs -->
                <div class="left-column">
                    <!-- Title and Mode Section -->
                    <div style="margin-bottom: 20px;">
                        <h1 style="margin-bottom: 16px;">Atomic-scale Simulation on Ion Irradiation of Matter (ASIM)</h1>
                        <div class="mode-selector" style="margin-bottom: 0;">
                            <label>
                                <input type="radio" name="input-mode" value="parameters" checked onchange="toggleInputMode()">
                                Parameter Input Mode
                            </label>
                            <label>
                                <input type="radio" name="input-mode" value="script" onchange="toggleInputMode()">
                                Script Editor Mode
                            </label>
                        </div>
                    </div>
                    
                    <!-- Working Directory Section -->
                    <div class="input-section" style="margin-bottom: 24px;">
                        <div class="working-directory-header">
                            <h2 style="margin-bottom: 16px;">Working Directory</h2>
                            <span id="working-directory-badge" class="working-directory-badge">Active</span>
                        </div>
                        <div class="path-autocomplete-container" style="margin-bottom: 12px;">
                            <input type="text" id="working-directory" placeholder="/path/to/your/simulation/folder" 
                                   style="width: 100%; padding: 10px 14px; border: 1px solid var(--border-color); 
                                          border-radius: 8px; font-size: 14px; font-family: 'JetBrains Mono', monospace;
                                          transition: border-color 0.2s ease;">
                            <div id="path-autocomplete-dropdown" class="path-autocomplete-dropdown"></div>
                        </div>
                        <button type="button" onclick="confirmWorkingDirectory()" class="confirm-button" id="confirm-directory-btn" style="width: 100%;">
                            <span>✓</span>
                            <span>Confirm Directory</span>
                        </button>
                        <div id="working-directory-status" class="working-directory-status">
                            <span class="status-icon"></span>
                            <span class="status-text"></span>
                        </div>
                    </div>
                    
                    <!-- Crystal Structure Section -->
                    <div class="input-section">
                        <h2>Crystal Structure</h2>
                        
                        <!-- Preload Templates -->
                        <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color);">
                            <label style="margin-bottom: 12px; font-weight: 600;">Quick Load Templates:</label>
                            <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                                <button type="button" class="template-button" onclick="loadTemplate('graphene')">Graphene</button>
                                <button type="button" class="template-button" onclick="loadTemplate('hBN')">h-BN</button>
                                <button type="button" class="template-button" onclick="loadTemplate('SiC')">SiC</button>
                                <button type="button" class="template-button" onclick="loadTemplate('Si')">Silicon</button>
                                <button type="button" class="template-button" onclick="loadTemplate('MoS2')">MoS₂</button>
                            </div>
                        </div>
                        
                        <label>Primary Vectors (3x3 diagonal matrix):</label>
                        <div class="matrix-input">
                            <div class="matrix-row">
                                <input type="number" id="pv-00" placeholder="a11" step="any" onchange="updateAtomCount()" oninput="updateAtomCount()">
                                <input type="number" id="pv-01" value="0.0" disabled>
                                <input type="number" id="pv-02" value="0.0" disabled>
                            </div>
                            <div class="matrix-row">
                                <input type="number" id="pv-10" value="0.0" disabled>
                                <input type="number" id="pv-11" placeholder="a22" step="any" onchange="updateAtomCount()" oninput="updateAtomCount()">
                                <input type="number" id="pv-12" value="0.0" disabled>
                            </div>
                            <div class="matrix-row">
                                <input type="number" id="pv-20" value="0.0" disabled>
                                <input type="number" id="pv-21" value="0.0" disabled>
                                <input type="number" id="pv-22" placeholder="a33" step="any" onchange="updateAtomCount()" oninput="updateAtomCount()">
                            </div>
                        </div>
                        
                        <div style="margin-top: 32px;">
                            <label>Basis Positions:</label>
                            <div class="basis-container" id="basis-container">
                                <!-- Basis positions will be added dynamically -->
                            </div>
                            <button type="button" class="add-button" onclick="addBasisPosition()">Add Basis Position</button>
                        </div>
                        
                        <div style="margin-top: 32px;">
                            <label>Crystal Elements:</label>
                            <div class="crystal-elements" id="crystal-elements">
                                <!-- Elements will be added dynamically -->
                            </div>
                            <button type="button" class="add-button" onclick="addCrystalElement()">Add Element</button>
                        </div>
                        
                        <div style="margin-top: 32px;">
                            <label>Grid Vectors (3x3 diagonal matrix):</label>
                            <div class="matrix-input">
                                <div class="matrix-row">
                                    <input type="number" id="gv-00" placeholder="g11" step="any" value="2.1">
                                    <input type="number" id="gv-01" value="0.0" disabled>
                                    <input type="number" id="gv-02" value="0.0" disabled>
                                </div>
                                <div class="matrix-row">
                                    <input type="number" id="gv-10" value="0.0" disabled>
                                    <input type="number" id="gv-11" placeholder="g22" step="any" value="2.1">
                                    <input type="number" id="gv-12" value="0.0" disabled>
                                </div>
                                <div class="matrix-row">
                                    <input type="number" id="gv-20" value="0.0" disabled>
                                    <input type="number" id="gv-21" value="0.0" disabled>
                                    <input type="number" id="gv-22" placeholder="g33" step="any" value="2.1">
                                </div>
                            </div>
                        </div>
                        
                        <div class="advanced-params">
                            <label>Box Sizes:</label>
                            <div class="coord-row">
                                <label>x:</label>
                                <input type="number" id="box-x" value="10" min="1" onchange="updateAtomCount()" oninput="updateAtomCount()">
                                <label>y:</label>
                                <input type="number" id="box-y" value="20" min="1" onchange="updateAtomCount()" oninput="updateAtomCount()">
                                <label>z:</label>
                                <input type="number" id="box-z" value="10" min="1" onchange="updateAtomCount()" oninput="updateAtomCount()">
                            </div>
                            
                            <label>Lattice Ranges:</label>
                            <div class="range-inputs">
                                <div class="range-row">
                                    <label>x:</label>
                                    <input type="number" id="range-x-min" value="0" step="any" onchange="updateAtomCount()" oninput="updateAtomCount()">
                                    <span>to</span>
                                    <input type="number" id="range-x-max" value="10" step="any" onchange="updateAtomCount()" oninput="updateAtomCount()">
                                </div>
                                <div class="range-row">
                                    <label>y:</label>
                                    <input type="number" id="range-y-min" value="0" step="any" onchange="updateAtomCount()" oninput="updateAtomCount()">
                                    <span>to</span>
                                    <input type="number" id="range-y-max" value="20" step="any" onchange="updateAtomCount()" oninput="updateAtomCount()">
                                </div>
                                <div class="range-row">
                                    <label>z:</label>
                                    <input type="number" id="range-z-min" value="5" step="any" onchange="updateAtomCount()" oninput="updateAtomCount()">
                                    <span>to</span>
                                    <input type="number" id="range-z-max" value="6" step="any" onchange="updateAtomCount()" oninput="updateAtomCount()">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Ion Configuration Section -->
                    <div class="input-section">
                        <h2>Ion Configuration</h2>
                        <div class="ion-params">
                            <label for="ion-symbol">Ion Symbol:</label>
                            <input type="text" id="ion-symbol" value="Ne" placeholder="e.g., Ne, Ar, He" class="medium-input">
                        </div>
                        
                        <label for="ion-energy">Ion Energy (eV):</label>
                        <input type="number" id="ion-energy" value="1000" step="1">
                        
                        <label>Ion Direction:</label>
                        <div class="coord-row">
                            <label>x:</label>
                            <input type="number" id="ion-dir-x" value="0.0" step="any" class="coord-input">
                            <label>y:</label>
                            <input type="number" id="ion-dir-y" value="0.0" step="any" class="coord-input">
                            <label>z:</label>
                            <input type="number" id="ion-dir-z" value="-1.0" step="any" class="coord-input">
                        </div>
                        
                        <div style="padding: 16px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color); margin-top: 16px;">
                            <p style="margin: 0; color: var(--text-secondary); font-size: 13px; line-height: 1.4;">
                                <strong>Note:</strong> Ion position is automatically set to random x,y coordinates within the box area and z-coordinate at 0.1 above the maximum z-coordinate of the box.
                            </p>
                        </div>
                    </div>
                    
                    <!-- Simulation Parameters Section -->
                    <div class="input-section">
                        <h2>Simulation Parameters</h2>
                        
                        <label for="repetitions">Number of Repetitions:</label>
                        <input type="number" id="repetitions" value="1000" min="1">
                        
                        <label>Irradiation Mode:</label>
                        <div class="mode-row">
                            <label><input type="radio" name="irradiation-mode" value="independent" checked> Independent Irradiation</label>
                            <label><input type="radio" name="irradiation-mode" value="continuous"> Continuous Irradiation</label>
                        </div>
                        
                        <label for="seed">Random Seed:</label>
                        <input type="number" id="seed" value="42">
                        
                        <div class="advanced-params">
                            <label for="pmax">pMax:</label>
                            <input type="number" id="pmax" value="1.45" step="0.01">
                            
                            <label for="vacancy-recover">Vacancy Recover Distance:</label>
                            <input type="number" id="vacancy-recover" value="1.3" step="0.1">
                            
                            <label for="stop-energy">Stop Energy:</label>
                            <input type="number" id="stop-energy" value="0.1" step="0.1">
                            
                            <label for="temperature">Temperature (K):</label>
                            <input type="number" id="temperature" value="0" step="0.1">
                            
                            <label for="debye-temperature">Debye Temperature (K):</label>
                            <input type="number" id="debye-temperature" value="645" step="0.1">
                            
                            <label>
                                <input type="checkbox" id="dynamic-load">
                                Dynamic Load Mode
                            </label>
                            
                            <div id="dynamic-options" class="hidden" style="margin-left: 20px; margin-top: 10px; padding: 12px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color);">
                                <label>
                                    <input type="checkbox" id="amorphous-mode">
                                    Amorphous (非晶)
                                </label>
                            </div>
                            
                            <div style="margin-top: 16px; padding: 12px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color);">
                                <p style="margin: 0 0 8px 0; font-weight: 500; color: var(--text-primary);">Recording Options:</p>
                                <label style="margin-right: 20px;">
                                    <input type="checkbox" id="record-vacancy" checked>
                                    Record Vacancy Count (nV.csv)
                                </label>
                                <label>
                                    <input type="checkbox" id="record-penetration" checked>
                                    Record Penetration Depth (R_p.csv)
                                </label>
                            </div>
                            
                            <!-- Reset Button -->
                            <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border-color); text-align: center;">
                                <button onclick="resetAllInputs()" 
                                        style="background: var(--warning-color); color: white; border: none; padding: 12px 24px; 
                                               border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; 
                                               transition: all 0.2s ease;">
                                    🔄 Reset All Parameters
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Column - Controls, 3D Viewer and Output -->
                <div class="right-column">
                    <!-- Control Buttons -->
                    <div class="control-section">
                        <button id="preview-button" class="preview-button" onclick="previewScript()">Preview Script</button>
                        <button id="run-button" onclick="runSimulation()">Run Simulation</button>
                        <button id="stop-button" class="stop-button" onclick="stopSimulation()" disabled>Stop</button>
                        <button onclick="clearOutput()">Clear Output</button>
                    </div>
                    
                    <!-- 3D Crystal Viewer -->
                    <div class="crystal-viewer-section">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <h2 style="margin: 0; font-size: 1.1rem;">Crystal Structure</h2>
                            <div class="viewer-controls" style="display: flex; gap: 8px;">
                                <button class="viewer-btn" onclick="resetCameraView()" title="Reset View">🏠</button>
                                <button class="viewer-btn" onclick="toggleProjection()" title="Toggle Projection">📐</button>
                                <button class="viewer-btn" onclick="viewFromAxis('x')" title="View from X">X</button>
                                <button class="viewer-btn" onclick="viewFromAxis('y')" title="View from Y">Y</button>
                                <button class="viewer-btn" onclick="viewFromAxis('z')" title="View from Z">Z</button>
                            </div>
                        </div>
                        <div id="crystal-viewer">
                            <div class="viewer-placeholder">
                                <div>
                                    <p>🔬 3D Crystal Viewer</p>
                                    <p style="font-size: 12px; margin-top: 8px;">Load a template or add basis positions to see the crystal structure</p>
                                </div>
                            </div>
                            
                            <!-- Bond threshold control in top-right corner -->
                            <div id="bond-control-panel" style="position: absolute; top: 8px; right: 8px; 
                                     background: rgba(255,255,255,0.95); border: 1px solid var(--border-color); 
                                     border-radius: 8px; padding: 8px 12px; backdrop-filter: blur(5px);
                                     box-shadow: 0 2px 8px rgba(0,0,0,0.1); min-width: 160px; z-index: 100;">
                                <div style="display: flex; flex-direction: column; gap: 6px;">
                                    <label style="margin: 0; font-size: 11px; font-weight: 600; color: var(--text-primary);">Bond Threshold</label>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <input type="number" id="bond-threshold" value="0" step="0.1" min="0" max="5" 
                                               style="width: 60px; padding: 4px 6px; border: 1px solid var(--border-color); 
                                                      border-radius: 4px; font-size: 11px; text-align: center;"
                                               onchange="updateCrystalViewer()" oninput="updateCrystalViewer()" 
                                               title="0 = auto detection, >0 = manual threshold">
                                        <span style="font-size: 11px; color: var(--text-secondary);">Å</span>
                                    </div>
                                    <div style="font-size: 10px; color: var(--text-secondary); line-height: 1.2;">
                                        <span id="bond-mode-info">Auto mode</span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- 3D viewer controls overlay at bottom -->
                            <div id="viewer-controls-overlay" style="position: absolute; bottom: 0; left: 0; right: 0; 
                                     background: rgba(255,255,255,0.95); border-top: 1px solid var(--border-color); 
                                     padding: 8px 12px; display: flex; justify-content: space-between; align-items: center; 
                                     font-size: 11px; backdrop-filter: blur(5px);">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <div style="color: var(--text-secondary);">
                                        Atoms: <span id="total-atoms" style="color: var(--primary-color); font-weight: 600;">0</span>
                                    </div>
                                </div>
                                <div id="viewer-info" style="color: var(--text-secondary);"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Simulation Output -->
                    <div class="output-section" style="flex: 1;">
                        <h2>Simulation Output</h2>
                        <div id="output">
                            <div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 40px; line-height: 1.6;">
                                <p>🚀 Click "Run Simulation" to start the DISPLATH simulation</p>
                                <p style="font-size: 14px; margin-top: 16px;">Real-time output from the Julia process will appear here.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Script Editor Mode -->
        <div id="script-mode" class="hidden">
            <div class="control-panel">
                <div class="section">
                    <label for="example-select">Load Example:</label>
                    <select id="example-select">
                        <option value="">-- Select an example --</option>
                    </select>
                    
                    <label for="threads-script">Number of Threads:</label>
                    <input type="number" id="threads-script" value="1" min="1" max="16">
                </div>
            </div>
            
            <div class="section">
                <label for="julia-script">Julia Script:</label>
                <textarea id="julia-script" placeholder="Enter your Julia code here..." style="min-height: 300px;"></textarea>
            </div>
        </div>
    </div>

    <!-- Script Preview Modal -->
    <div id="scriptModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Generated Julia Script</h2>
                <span class="close" onclick="closeScriptModal()">&times;</span>
            </div>
            <div class="modal-body">
                <pre id="script-preview-modal">Click "Preview Script" to generate the Julia script...</pre>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let currentProcessId = null;
        let elementPresets = {};
        let nextElementId = 1;
        let nextBasisId = 1;
        
        // Crystal structure templates
        const crystalTemplates = {
            graphene: {
                name: "Graphene", 
                primaryVectors: [4.26, 0, 0, 0, 2.46, 0, 0, 0, 3.35], // 3.0*1.42, sqrt(3)*1.42, 3.35
                gridVectors: [2.982, 0, 0, 0, 2.982, 0, 0, 0, 2.982], // 1.42*2.1
                boxSizes: [10, 20, 10],
                latticeRanges: [[0, 10], [0, 20], [5, 6]],
                basisPositions: [
                    [0.0, 0.0, 0.0],
                    [0.333, 0.0, 0.0],
                    [0.5, 0.5, 0.0],
                    [0.833, 0.5, 0.0]
                ],
                basisTypes: [1, 1, 1, 1],
                elements: [
                    {symbol: "C", ed: 22.0, displacement_energy: 11.0}
                ]
            },
            hBN: {
                name: "Hexagonal Boron Nitride",
                primaryVectors: [4.338, 0, 0, 0, 2.505, 0, 0, 0, 3.35], // 3.0*1.446, sqrt(3)*1.446, 3.35
                gridVectors: [3.035, 0, 0, 0, 3.035, 0, 0, 0, 3.035], // 1.446*2.1
                boxSizes: [10, 20, 10],
                latticeRanges: [[0, 10], [0, 20], [5, 6]],
                basisPositions: [
                    [0.0, 0.0, 0.0],
                    [0.333, 0.0, 0.0],
                    [0.5, 0.5, 0.0],
                    [0.833, 0.5, 0.0]
                ],
                basisTypes: [1, 2, 1, 2], // 交替的B和N原子
                elements: [
                    {symbol: "B", ed: 18.3, displacement_energy: 9.15},
                    {symbol: "N", ed: 18.6, displacement_energy: 9.3}
                ]
            },
            SiC: {
                name: "Silicon Carbide",
                primaryVectors: [4.36, 0, 0, 0, 4.36, 0, 0, 0, 4.36],
                gridVectors: [2.18, 0, 0, 0, 2.18, 0, 0, 0, 2.18],
                boxSizes: [20, 20, 20],
                latticeRanges: [[0, 20], [0, 20], [1, 19]],
                basisPositions: [
                    [0.0, 0.0, 0.0],
                    [0.5, 0.5, 0.0],
                    [0.5, 0.0, 0.5],
                    [0.0, 0.5, 0.5],
                    [0.25, 0.25, 0.25],
                    [0.75, 0.75, 0.25],
                    [0.75, 0.25, 0.75],
                    [0.25, 0.75, 0.75]
                ],
                basisTypes: [1, 1, 1, 1, 2, 2, 2, 2],
                elements: [
                    {symbol: "Si", ed: 20.0, displacement_energy: 10.0},
                    {symbol: "C", ed: 22.0, displacement_energy: 11.0}
                ]
            },
            Si: {
                name: "Silicon",
                primaryVectors: [5.431, 0, 0, 0, 5.431, 0, 0, 0, 5.431],
                gridVectors: [2.7, 0, 0, 0, 2.7, 0, 0, 0, 2.7],
                boxSizes: [50, 50, 100],
                latticeRanges: [[0, 50], [0, 50], [2, 98]],
                basisPositions: [
                    [0.0, 0.0, 0.0],
                    [0.5, 0.5, 0.0],
                    [0.5, 0.0, 0.5],
                    [0.0, 0.5, 0.5],
                    [0.25, 0.25, 0.25],
                    [0.75, 0.75, 0.25],
                    [0.75, 0.25, 0.75],
                    [0.25, 0.75, 0.75]
                ],
                basisTypes: [1, 1, 1, 1, 1, 1, 1, 1],
                elements: [
                    {symbol: "Si", ed: 20.0, displacement_energy: 10.0}
                ]
            },
            MoS2: {
                name: "Molybdenum Disulfide",
                primaryVectors: [3.196, 0, 0, 0, 5.536, 0, 0, 0, 23.13],
                gridVectors: [3.0, 0, 0, 0, 3.0, 0, 0, 0, 3.0],
                boxSizes: [15, 8, 3],
                latticeRanges: [[0, 15], [0, 8], [1, 2]],
                basisPositions: [
                    [0.5, 0.167, 0.5],
                    [0.0, 0.667, 0.5],
                    [0.5, 0.833, 0.432],
                    [0.0, 0.333, 0.432],
                    [0.5, 0.833, 0.568],
                    [0.0, 0.333, 0.568]
                ],
                basisTypes: [1, 1, 2, 2, 2, 2],
                elements: [
                    {symbol: "S", ed: 7.8, displacement_energy: 3.9},
                    {symbol: "Mo", ed: 29.1, displacement_energy: 14.55}
                ]
            }
        };
        
        // 3D Crystal Viewer
        let scene, camera, renderer, controls;
        let crystalGroup;
        let perspectiveCamera, orthographicCamera;
        let isOrthographic = false;
        
        // Element colors for 3D visualization
        const elementColors = {
            'C': 0x404040,   // Dark gray
            'Si': 0x4169e1,  // Royal blue
            'B': 0xff6b6b,   // Light red
            'N': 0x4ecdc4,   // Teal
            'S': 0xffeb3b,   // Yellow
            'Mo': 0x9c27b0,  // Purple
            'O': 0xf44336,   // Red
            'H': 0xffffff,   // White
            'default': 0x808080  // Gray for unknown elements
        };

        // Bond distance thresholds for different element pairs (in Angstroms)
        const bondDistances = {
            'C-C': 1.8,      // Graphene, diamond
            'Si-Si': 2.8,    // Silicon crystal
            'B-N': 1.7,      // Hexagonal BN
            'B-B': 1.8,      
            'N-N': 1.6,      
            'S-Mo': 2.6,     // MoS2
            'S-S': 1.1,      
            'Mo-Mo': 1.1,    
            'default': 2.2
        };

        function getBondDistance(elem1, elem2) {
            const key1 = `${elem1}-${elem2}`;
            const key2 = `${elem2}-${elem1}`;
            return bondDistances[key1] || bondDistances[key2] || bondDistances['default'];
        }
        
        function updateBondModeInfo(userThreshold) {
            const bondModeInfo = document.getElementById('bond-mode-info');
            if (!bondModeInfo) return;
            
            if (userThreshold > 0) {
                bondModeInfo.textContent = `Manual: ${userThreshold.toFixed(1)}Å`;
                bondModeInfo.style.color = 'var(--primary-color)';
            } else {
                bondModeInfo.textContent = 'Auto mode';
                bondModeInfo.style.color = 'var(--text-secondary)';
            }
        }
        
        function initCrystalViewer() {
            const container = document.getElementById('crystal-viewer');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);  // Light gray background
            
            // Camera setup - both perspective and orthographic
            const aspect = container.clientWidth / container.clientHeight;
            perspectiveCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            perspectiveCamera.position.set(10, -10, 8);  // x=right/left, y=front/back, z=up/down
            perspectiveCamera.up.set(0, 0, 1);  // Set z-axis as up direction
            
            const frustumSize = 10;
            orthographicCamera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2,
                0.1, 1000
            );
            orthographicCamera.position.set(10, -10, 8);  // x=right/left, y=front/back, z=up/down
            orthographicCamera.up.set(0, 0, 1);  // Set z-axis as up direction
            
            camera = perspectiveCamera; // Start with perspective
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Clear placeholder and add renderer
            container.innerHTML = '';
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;  // Disable "oily" inertia effect
            controls.enableZoom = true;
            controls.enablePan = true;  // Enable right-click panning
            
            // Lighting - enhanced for better visibility
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);
            
            // Crystal group for atoms
            crystalGroup = new THREE.Group();
            scene.add(crystalGroup);
            
            // Add info overlay
            const infoDiv = document.createElement('div');
            infoDiv.className = 'viewer-info';
            infoDiv.id = 'viewer-info';
            infoDiv.textContent = 'No crystal structure';
            container.appendChild(infoDiv);
            
            // Animation loop
            animate();
            
            // Handle resize
            window.addEventListener('resize', () => {
                if (!renderer || !camera) return;
                
                const container = document.getElementById('crystal-viewer');
                const width = container.clientWidth;
                const height = container.clientHeight;
                const aspect = width / height;
                
                if (perspectiveCamera) {
                    perspectiveCamera.aspect = aspect;
                    perspectiveCamera.updateProjectionMatrix();
                }
                
                if (orthographicCamera) {
                    const frustumSize = 10;
                    orthographicCamera.left = frustumSize * aspect / -2;
                    orthographicCamera.right = frustumSize * aspect / 2;
                    orthographicCamera.updateProjectionMatrix();
                }
                
                renderer.setSize(width, height);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function updateCrystalViewer() {
            if (!scene) return;
            
            // Clear existing content
            crystalGroup.clear();
            
            // Get crystal parameters - use lattice ranges for atom count
            const xMin = parseFloat(document.getElementById('range-x-min').value) || 0;
            const xMax = parseFloat(document.getElementById('range-x-max').value) || 0;
            const yMin = parseFloat(document.getElementById('range-y-min').value) || 0;
            const yMax = parseFloat(document.getElementById('range-y-max').value) || 0;
            const zMin = parseFloat(document.getElementById('range-z-min').value) || 0;
            const zMax = parseFloat(document.getElementById('range-z-max').value) || 0;
            
            const rangeX = Math.max(0, Math.floor(xMax - xMin));
            const rangeY = Math.max(0, Math.floor(yMax - yMin));
            const rangeZ = Math.max(0, Math.floor(zMax - zMin));
            
            const basisRows = document.querySelectorAll('.basis-row');
            const numBasisAtoms = basisRows.length;
            const totalAtoms = rangeX * rangeY * rangeZ * numBasisAtoms;
            
            console.log(`3D Viewer: Calculated ${totalAtoms} atoms from lattice ranges (${rangeX}*${rangeY}*${rangeZ}*${numBasisAtoms})`);
            
            // Check if we have any crystal structure
            if (totalAtoms === 0) {
                const viewerInfo = document.getElementById('viewer-info');
                if (viewerInfo) {
                    viewerInfo.textContent = 'No crystal structure';
                }
                return;
            }
            
            // Always show borders
            createBorders();
            
            // Show atoms only if under limit
            if (totalAtoms <= 3000) {
                // Generate crystal structure
                const atoms = generateCrystalStructure();
                console.log(`Generated ${atoms.length} atoms for 3D display`);
                
                if (atoms.length > 0) {
                    // Create atom geometries and materials
                    const atomGeometry = new THREE.SphereGeometry(0.3, 16, 12);
                    const materials = {};
                    
                    // Create materials for each element
                    Object.keys(elementColors).forEach(element => {
                        materials[element] = new THREE.MeshPhongMaterial({ 
                            color: elementColors[element],
                            emissive: elementColors[element],
                            emissiveIntensity: 0.2,
                            shininess: 100,
                            specular: 0x222222
                        });
                    });
                    
                    // Add atoms to scene
                    atoms.forEach(atom => {
                        const material = materials[atom.element] || materials['default'];
                        const atomMesh = new THREE.Mesh(atomGeometry, material);
                        atomMesh.position.set(atom.x, atom.y, atom.z);
                        atomMesh.castShadow = true;
                        atomMesh.receiveShadow = true;
                        crystalGroup.add(atomMesh);
                    });

                    // Add bonds between atoms
                    const bondMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x666666,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    for (let i = 0; i < atoms.length; i++) {
                        for (let j = i + 1; j < atoms.length; j++) {
                            const atom1 = atoms[i];
                            const atom2 = atoms[j];
                            
                            const distance = Math.sqrt(
                                Math.pow(atom1.x - atom2.x, 2) +
                                Math.pow(atom1.y - atom2.y, 2) +
                                Math.pow(atom1.z - atom2.z, 2)
                            );
                            
                            // Get user-defined bond threshold
                            const bondThresholdElement = document.getElementById('bond-threshold');
                            const userThresholdInput = bondThresholdElement ? bondThresholdElement.value : '0';
                            const userThreshold = parseFloat(userThresholdInput) || 0;
                            
                            // Use user threshold if > 0, otherwise use auto detection
                            const bondThreshold = userThreshold > 0 ? userThreshold : getBondDistance(atom1.element, atom2.element);
                            
                            // Update bond mode info (only once per update)
                            if (i === 0 && j === 1) {
                                updateBondModeInfo(userThreshold);
                            }
                            
                            if (distance <= bondThreshold) {
                                // Create cylinder for bond
                                const bondGeometry = new THREE.CylinderGeometry(0.05, 0.05, distance, 8);
                                const bondMesh = new THREE.Mesh(bondGeometry, bondMaterial);
                                
                                // Position and orient the bond
                                const midpoint = new THREE.Vector3(
                                    (atom1.x + atom2.x) / 2,
                                    (atom1.y + atom2.y) / 2,
                                    (atom1.z + atom2.z) / 2
                                );
                                bondMesh.position.copy(midpoint);
                                
                                // Orient cylinder along bond direction
                                const direction = new THREE.Vector3(
                                    atom2.x - atom1.x,
                                    atom2.y - atom1.y,
                                    atom2.z - atom1.z
                                ).normalize();
                                
                                const axis = new THREE.Vector3(0, 1, 0);
                                const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, direction);
                                bondMesh.quaternion.copy(quaternion);
                                
                                crystalGroup.add(bondMesh);
                            }
                        }
                    }
                }
            }
            
            // Calculate center and scale based on actual structure bounds
            let centerX = 0, centerY = 0, centerZ = 0;
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity; 
            let minZ = Infinity, maxZ = -Infinity;
            
            // Calculate bounds from box and crystal region
            const boxX = parseFloat(document.getElementById('box-x').value) || 10;
            const boxY = parseFloat(document.getElementById('box-y').value) || 10;
            const boxZ = parseFloat(document.getElementById('box-z').value) || 10;
            const pv00 = parseFloat(document.getElementById('pv-00').value) || 1;
            const pv11 = parseFloat(document.getElementById('pv-11').value) || 1;
            const pv22 = parseFloat(document.getElementById('pv-22').value) || 1;
            
            // Use the larger of box or crystal region for bounds
            const crystalXMin = xMin * pv00;
            const crystalXMax = xMax * pv00;
            const crystalYMin = yMin * pv11;
            const crystalYMax = yMax * pv11;
            const crystalZMin = zMin * pv22;
            const crystalZMax = zMax * pv22;
            
            const boxXMax = boxX * pv00;
            const boxYMax = boxY * pv11;
            const boxZMax = boxZ * pv22;
            
            minX = Math.min(0, crystalXMin);
            maxX = Math.max(boxXMax, crystalXMax);
            minY = Math.min(0, crystalYMin);
            maxY = Math.max(boxYMax, crystalYMax);
            minZ = Math.min(0, crystalZMin);
            maxZ = Math.max(boxZMax, crystalZMax);
            
            // Calculate center point
            centerX = (minX + maxX) / 2;
            centerY = (minY + maxY) / 2;
            centerZ = (minZ + maxZ) / 2;
            
            // Calculate size for scaling
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxSize = Math.max(sizeX, sizeY, sizeZ);
            
            // Center the structure at origin
            crystalGroup.position.set(-centerX, -centerY, -centerZ);
            
            if (maxSize > 0) {
                const scale = 12 / maxSize;
                crystalGroup.scale.setScalar(scale);
                
                // Apply scale to centered position
                crystalGroup.position.multiplyScalar(scale);
            }
            
            // Update camera and controls to focus on the new center
            const distance = 15;
            camera.position.set(distance, -distance, distance * 0.6);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
            
            // Update info
            const viewerInfo = document.getElementById('viewer-info');
            if (viewerInfo) {
                if (totalAtoms > 3000) {
                    viewerInfo.textContent = `Borders only (${totalAtoms.toLocaleString()} atoms - limit 2,000)`;
                } else {
                    viewerInfo.textContent = `${totalAtoms.toLocaleString()} atoms`;
                }
            }
        }
        
        function createBorders() {
            // Get box dimensions
            const boxX = parseFloat(document.getElementById('box-x').value) || 10;
            const boxY = parseFloat(document.getElementById('box-y').value) || 10;
            const boxZ = parseFloat(document.getElementById('box-z').value) || 10;
            
            // Get primary vectors
            const pv00 = parseFloat(document.getElementById('pv-00').value) || 1;
            const pv11 = parseFloat(document.getElementById('pv-11').value) || 1;
            const pv22 = parseFloat(document.getElementById('pv-22').value) || 1;
            
            // Get lattice ranges
            const xMin = parseFloat(document.getElementById('range-x-min').value) || 0;
            const xMax = parseFloat(document.getElementById('range-x-max').value) || boxX;
            const yMin = parseFloat(document.getElementById('range-y-min').value) || 0;
            const yMax = parseFloat(document.getElementById('range-y-max').value) || boxY;
            const zMin = parseFloat(document.getElementById('range-z-min').value) || 0;
            const zMax = parseFloat(document.getElementById('range-z-max').value) || boxZ;
            
            // Border materials with better color scheme
            const boxBorderMaterial = new THREE.LineBasicMaterial({ 
                color: 0x6366f1,  // Indigo - simulation box
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });
            
            const crystalBorderMaterial = new THREE.LineBasicMaterial({ 
                color: 0x10b981,  // Emerald green - crystal region
                linewidth: 3,
                transparent: true,
                opacity: 0.9
            });
            
            // Create box borders (full simulation box)
            createWireframeBorder(
                0, 0, 0,
                boxX * pv00, boxY * pv11, boxZ * pv22,
                boxBorderMaterial,
                'Box Boundaries'
            );
            
            // Create crystal region borders (lattice ranges)
            createWireframeBorder(
                xMin * pv00, yMin * pv11, zMin * pv22,
                xMax * pv00, yMax * pv11, zMax * pv22,
                crystalBorderMaterial,
                'Crystal Region'
            );
            
            // Add semi-transparent faces for lattice region when atoms > 3000
            const basisRows = document.querySelectorAll('.basis-row');
            const numBasisAtoms = basisRows.length;
            const rangeX = Math.max(0, Math.floor(xMax - xMin));
            const rangeY = Math.max(0, Math.floor(yMax - yMin));
            const rangeZ = Math.max(0, Math.floor(zMax - zMin));
            const totalAtoms = rangeX * rangeY * rangeZ * numBasisAtoms;
            
            if (totalAtoms > 3000) {
                createTransparentFaces(
                    xMin * pv00, yMin * pv11, zMin * pv22,
                    xMax * pv00, yMax * pv11, zMax * pv22
                );
            }
        }
        
        function createWireframeBorder(x1, y1, z1, x2, y2, z2, material, label) {
            const geometry = new THREE.BufferGeometry();
            
            // Define the 8 vertices of the box
            const vertices = new Float32Array([
                // Bottom face
                x1, y1, z1,  x2, y1, z1,  // bottom edge 1
                x2, y1, z1,  x2, y2, z1,  // bottom edge 2
                x2, y2, z1,  x1, y2, z1,  // bottom edge 3
                x1, y2, z1,  x1, y1, z1,  // bottom edge 4
                
                // Top face
                x1, y1, z2,  x2, y1, z2,  // top edge 1
                x2, y1, z2,  x2, y2, z2,  // top edge 2
                x2, y2, z2,  x1, y2, z2,  // top edge 3
                x1, y2, z2,  x1, y1, z2,  // top edge 4
                
                // Vertical edges
                x1, y1, z1,  x1, y1, z2,  // vertical edge 1
                x2, y1, z1,  x2, y1, z2,  // vertical edge 2
                x2, y2, z1,  x2, y2, z2,  // vertical edge 3
                x1, y2, z1,  x1, y2, z2   // vertical edge 4
            ]);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            
            const wireframe = new THREE.LineSegments(geometry, material);
            crystalGroup.add(wireframe);
        }
        
        function createTransparentFaces(x1, y1, z1, x2, y2, z2) {
            // Material for semi-transparent faces
            const faceMaterial = new THREE.MeshBasicMaterial({
                color: 0x10b981,  // Same green as border
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            
            // Create geometry for a box
            const width = x2 - x1;
            const height = y2 - y1;
            const depth = z2 - z1;
            
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const mesh = new THREE.Mesh(geometry, faceMaterial);
            
            // Position at center of the box
            mesh.position.set(
                (x1 + x2) / 2,
                (y1 + y2) / 2,
                (z1 + z2) / 2
            );
            
            crystalGroup.add(mesh);
        }
        
        function generateCrystalStructure() {
            const atoms = [];
            
            try {
                // Get parameters
                const boxX = parseInt(document.getElementById('box-x').value) || 0;
                const boxY = parseInt(document.getElementById('box-y').value) || 0;
                const boxZ = parseInt(document.getElementById('box-z').value) || 0;
                
                const pv00 = parseFloat(document.getElementById('pv-00').value) || 1;
                const pv11 = parseFloat(document.getElementById('pv-11').value) || 1;
                const pv22 = parseFloat(document.getElementById('pv-22').value) || 1;
                
                // Get lattice ranges for proper bounds
                const xMin = parseFloat(document.getElementById('range-x-min').value) || 0;
                const xMax = parseFloat(document.getElementById('range-x-max').value) || boxX;
                const yMin = parseFloat(document.getElementById('range-y-min').value) || 0;
                const yMax = parseFloat(document.getElementById('range-y-max').value) || boxY;
                const zMin = parseFloat(document.getElementById('range-z-min').value) || 0;
                const zMax = parseFloat(document.getElementById('range-z-max').value) || boxZ;
                
                // Get basis positions and types
                const basisRows = document.querySelectorAll('.basis-row');
                const elementRows = document.querySelectorAll('.element-row');
                
                console.log(`generateCrystalStructure: ${basisRows.length} basis rows, ${elementRows.length} element rows`);
                
                if (basisRows.length === 0) {
                    console.log('No basis positions found');
                    return atoms;
                }
                
                if (elementRows.length === 0) {
                    console.log('No element rows found');
                    return atoms;
                }
                
                // Create element lookup
                const elements = {};
                elementRows.forEach(row => {
                    const id = row.id.split('-')[1];
                    const symbol = document.getElementById(`symbol-${id}`).value;
                    if (symbol) {
                        const typeIndex = Object.keys(elements).length + 1;
                        elements[typeIndex] = symbol;
                    }
                });
                
                // Generate atoms using lattice ranges
                for (let i = Math.floor(xMin); i < Math.ceil(xMax); i++) {
                    for (let j = Math.floor(yMin); j < Math.ceil(yMax); j++) {
                        for (let k = Math.floor(zMin); k < Math.ceil(zMax); k++) {
                            basisRows.forEach(row => {
                                const rowId = row.id.split('-')[1];
                                const bx = parseFloat(document.getElementById(`basis-x-${rowId}`).value) || 0;
                                const by = parseFloat(document.getElementById(`basis-y-${rowId}`).value) || 0;
                                const bz = parseFloat(document.getElementById(`basis-z-${rowId}`).value) || 0;
                                const type = parseInt(document.getElementById(`basis-type-${rowId}`).value) || 1;
                                
                                const x = (i + bx) * pv00;
                                const y = (j + by) * pv11;
                                const z = (k + bz) * pv22;
                                
                                // Only add atoms within the actual lattice range bounds
                                if (i + bx >= xMin && i + bx < xMax &&
                                    j + by >= yMin && j + by < yMax &&
                                    k + bz >= zMin && k + bz < zMax) {
                                    atoms.push({
                                        x: x,
                                        y: y,
                                        z: z,
                                        element: elements[type] || 'C'
                                    });
                                }
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('Error generating crystal structure:', error);
            }
            
            return atoms;
        }
        
        // Camera control functions
        function resetCameraView() {
            if (!camera || !controls) return;
            
            const distance = 15;
            camera.position.set(distance, -distance, distance * 0.6);  // x=right, y=back, z=up
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        function toggleProjection() {
            if (!renderer || !controls) return;
            
            isOrthographic = !isOrthographic;
            
            if (isOrthographic) {
                orthographicCamera.position.copy(camera.position);
                orthographicCamera.rotation.copy(camera.rotation);
                camera = orthographicCamera;
            } else {
                perspectiveCamera.position.copy(camera.position);
                perspectiveCamera.rotation.copy(camera.rotation);
                camera = perspectiveCamera;
            }
            
            controls.object = camera;
            controls.update();
        }
        
        function viewFromAxis(axis) {
            if (!camera || !controls) return;
            
            const distance = 15;
            switch(axis) {
                case 'x':
                    camera.position.set(distance, 0, 0);  // View from right side
                    break;
                case 'y':
                    camera.position.set(0, -distance, 0);  // View from front
                    break;
                case 'z':
                    camera.position.set(0, 0, distance);  // View from top (z-up)
                    break;
            }
            
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        // Load element presets and examples on page load
        window.onload = function() {
            loadElementPresets();
            loadExamples();
            // Don't add default elements/positions - let user choose template or add manually
            
            // Dynamic load checkbox handler
            document.getElementById('dynamic-load').addEventListener('change', function() {
                document.getElementById('dynamic-options').classList.toggle('hidden', !this.checked);
            });
            
            // Update atom count initially
            updateAtomCount();
            
            // Set default working directory
            setCurrentDirectory();
            
            // Initialize 3D viewer
            setTimeout(() => {
                initCrystalViewer();
            }, 100);
        };
        
        function loadTemplate(templateName) {
            console.log('Loading template:', templateName);
            const template = crystalTemplates[templateName];
            console.log('Template data:', template);
            if (!template) {
                console.error('Template not found:', templateName);
                return;
            }
            
            // Clear existing basis positions and elements
            clearAllBasisPositions();
            clearAllCrystalElements();
            console.log('Cleared existing data');
            
            // Load primary vectors
            const pv = template.primaryVectors;
            document.getElementById('pv-00').value = pv[0];
            document.getElementById('pv-11').value = pv[4];
            document.getElementById('pv-22').value = pv[8];
            
            // Load grid vectors
            const gv = template.gridVectors;
            document.getElementById('gv-00').value = gv[0];
            document.getElementById('gv-11').value = gv[4];
            document.getElementById('gv-22').value = gv[8];
            
            // Load box sizes
            document.getElementById('box-x').value = template.boxSizes[0];
            document.getElementById('box-y').value = template.boxSizes[1];
            document.getElementById('box-z').value = template.boxSizes[2];
            
            // Load lattice ranges
            document.getElementById('range-x-min').value = template.latticeRanges[0][0];
            document.getElementById('range-x-max').value = template.latticeRanges[0][1];
            document.getElementById('range-y-min').value = template.latticeRanges[1][0];
            document.getElementById('range-y-max').value = template.latticeRanges[1][1];
            document.getElementById('range-z-min').value = template.latticeRanges[2][0];
            document.getElementById('range-z-max').value = template.latticeRanges[2][1];
            
            // Load basis positions
            console.log('Loading basis positions:', template.basisPositions);
            template.basisPositions.forEach((pos, index) => {
                console.log(`Adding basis position ${index}:`, pos);
                addBasisPosition();
                document.getElementById(`basis-x-${nextBasisId - 1}`).value = pos[0];
                document.getElementById(`basis-y-${nextBasisId - 1}`).value = pos[1];
                document.getElementById(`basis-z-${nextBasisId - 1}`).value = pos[2];
                document.getElementById(`basis-type-${nextBasisId - 1}`).value = template.basisTypes[index];
            });
            
            // Load crystal elements
            console.log('Loading crystal elements:', template.elements);
            template.elements.forEach((elem, index) => {
                console.log(`Processing element ${index}:`, elem);
                addCrystalElement();
                const currentElementId = nextElementId - 1; // Capture ID immediately after creation
                // Use setTimeout to ensure DOM elements are created
                setTimeout(() => {
                    console.log(`Setting values for element ID ${currentElementId}`);
                    const symbolInput = document.getElementById(`symbol-${currentElementId}`);
                    const edInput = document.getElementById(`ed-${currentElementId}`);
                    const dispInput = document.getElementById(`disp-${currentElementId}`);
                    
                    console.log('Found inputs:', {symbolInput, edInput, dispInput});
                    
                    if (symbolInput) symbolInput.value = elem.symbol;
                    if (edInput) edInput.value = elem.ed;
                    if (dispInput) dispInput.value = elem.displacement_energy;
                    
                    console.log(`Set values: ${elem.symbol}, ${elem.ed}, ${elem.displacement_energy}`);
                }, 10);
            });
            
            // Update atom count and 3D viewer with delay to ensure all DOM elements are created
            setTimeout(() => {
                console.log('Delayed update starting...');
                updateAtomCount();
            }, 200); // Longer delay to ensure 3D viewer is initialized
            setTimeout(updateCrystalViewer, 300);
        }
        
        function clearAllBasisPositions() {
            const container = document.getElementById('basis-container');
            container.innerHTML = '';
            nextBasisId = 1;
        }
        
        function clearAllCrystalElements() {
            const container = document.getElementById('crystal-elements');
            container.innerHTML = '';
            nextElementId = 1;
        }
        
        function updateAtomCount() {
            // Calculate total atoms based on LATTICE RANGES (not box sizes) and basis positions
            const xMin = parseFloat(document.getElementById('range-x-min').value) || 0;
            const xMax = parseFloat(document.getElementById('range-x-max').value) || 0;
            const yMin = parseFloat(document.getElementById('range-y-min').value) || 0;
            const yMax = parseFloat(document.getElementById('range-y-max').value) || 0;
            const zMin = parseFloat(document.getElementById('range-z-min').value) || 0;
            const zMax = parseFloat(document.getElementById('range-z-max').value) || 0;
            
            const rangeX = Math.max(0, Math.floor(xMax - xMin));
            const rangeY = Math.max(0, Math.floor(yMax - yMin));
            const rangeZ = Math.max(0, Math.floor(zMax - zMin));
            
            const basisRows = document.querySelectorAll('.basis-row');
            const numBasisAtoms = basisRows.length;
            
            const totalAtoms = rangeX * rangeY * rangeZ * numBasisAtoms;
            console.log(`Atom count calculation: (${xMax}-${xMin})*(${yMax}-${yMin})*(${zMax}-${zMin})*${numBasisAtoms} = ${rangeX}*${rangeY}*${rangeZ}*${numBasisAtoms} = ${totalAtoms}`);
            
            const totalAtomsElement = document.getElementById('total-atoms');
            if (totalAtomsElement) {
                totalAtomsElement.textContent = totalAtoms.toLocaleString();
                console.log(`Updated total-atoms element to: ${totalAtoms}`);
            } else {
                console.log('total-atoms element not found');
            }
            
            // Update 3D crystal viewer
            updateCrystalViewer();
        }
        
        function toggleInputMode() {
            const mode = document.querySelector('input[name="input-mode"]:checked').value;
            document.getElementById('parameter-mode').classList.toggle('hidden', mode !== 'parameters');
            document.getElementById('script-mode').classList.toggle('hidden', mode !== 'script');
            document.getElementById('preview-button').classList.toggle('hidden', mode !== 'parameters');
        }
        
        function loadElementPresets() {
            fetch('/get_element_presets')
                .then(response => response.json())
                .then(data => {
                    elementPresets = data;
                    // Ion symbol is now a text input, no need to populate options
                });
        }
        
        function updateIonParams() {
            // Ion parameters are automatically set - no manual Ed input needed
        }
        
        function addCrystalElement() {
            const container = document.getElementById('crystal-elements');
            console.log('Crystal elements container:', container);
            if (!container) {
                console.error('Could not find crystal-elements container');
                return;
            }
            
            const elementDiv = document.createElement('div');
            elementDiv.className = 'element-row';
            elementDiv.id = 'element-' + nextElementId;
            
            elementDiv.innerHTML = `
                <label style="min-width: 80px;">Type ${nextElementId}:</label>
                <input type="text" class="small-input" placeholder="Symbol" id="symbol-${nextElementId}">
                <input type="number" class="medium-input" placeholder="Ed" step="0.1" id="ed-${nextElementId}">
                <input type="number" class="medium-input" placeholder="Eb" step="0.1" id="disp-${nextElementId}">
                <button type="button" class="remove-button" onclick="removeCrystalElement(${nextElementId})">Remove</button>
            `;
            
            container.appendChild(elementDiv);
            console.log(`Added element ${nextElementId}, container now has ${container.children.length} children`);
            nextElementId++;
            updateAtomCount(); // This will trigger 3D viewer update
        }
        
        function removeCrystalElement(id) {
            const element = document.getElementById('element-' + id);
            if (element) {
                element.remove();
                updateAtomCount(); // This will trigger 3D viewer update
            }
        }
        
        function addBasisPosition() {
            const container = document.getElementById('basis-container');
            const basisDiv = document.createElement('div');
            basisDiv.className = 'basis-row';
            basisDiv.id = 'basis-' + nextBasisId;
            
            basisDiv.innerHTML = `
                <label style="margin-bottom: 0; width: 30px;">x:</label>
                <input type="number" class="coord-input" placeholder="0.0" step="any" id="basis-x-${nextBasisId}" onchange="updateAtomCount()" oninput="updateAtomCount()">
                <label style="margin-bottom: 0; width: 30px;">y:</label>
                <input type="number" class="coord-input" placeholder="0.0" step="any" id="basis-y-${nextBasisId}" onchange="updateAtomCount()" oninput="updateAtomCount()">
                <label style="margin-bottom: 0; width: 30px;">z:</label>
                <input type="number" class="coord-input" placeholder="0.0" step="any" id="basis-z-${nextBasisId}" onchange="updateAtomCount()" oninput="updateAtomCount()">
                <label style="margin-bottom: 0; width: 50px;">Type:</label>
                <input type="number" class="type-input" placeholder="1" min="1" id="basis-type-${nextBasisId}" value="1" onchange="updateAtomCount()" oninput="updateAtomCount()">
                <button type="button" class="remove-button" onclick="removeBasisPosition(${nextBasisId})">Remove</button>
            `;
            
            container.appendChild(basisDiv);
            nextBasisId++;
            updateAtomCount();
        }
        
        function removeBasisPosition(id) {
            const element = document.getElementById('basis-' + id);
            if (element) {
                element.remove();
                updateAtomCount();
            }
        }
        
        
        function loadExamples() {
            fetch('/get_examples')
                .then(response => response.json())
                .then(examples => {
                    const select = document.getElementById('example-select');
                    examples.forEach(example => {
                        const option = document.createElement('option');
                        option.value = example;
                        option.textContent = example;
                        select.appendChild(option);
                    });
                });
        }
        
        // Load selected example
        document.getElementById('example-select').addEventListener('change', function() {
            const selectedExample = this.value;
            if (selectedExample) {
                fetch(`/load_example/${selectedExample}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            document.getElementById('julia-script').value = data.content;
                        } else {
                            addOutput(`Error loading example: ${data.error}`, 'error');
                        }
                    });
            }
        });
        
        // Ion symbol is now a text input, no change event needed
        
        // Working directory functions
        function setCurrentDirectory() {
            fetch('/get_current_directory')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        document.getElementById('working-directory').value = data.directory;
                        addOutput(`Working directory set to: ${data.directory}`, 'success');
                    } else {
                        addOutput(`Error getting current directory: ${data.error}`, 'error');
                    }
                });
        }
        
        // Path autocomplete functionality
        let currentSuggestionIndex = -1;
        let pathSuggestions = [];
        let autocompleteTimeout = null;
        
        const workingDirInput = document.getElementById('working-directory');
        const autocompleteDropdown = document.getElementById('path-autocomplete-dropdown');
        
        // Initialize autocomplete
        workingDirInput.addEventListener('input', function(e) {
            clearTimeout(autocompleteTimeout);
            autocompleteTimeout = setTimeout(() => {
                fetchPathSuggestions(e.target.value);
            }, 200); // Debounce for 200ms
            
            // Reset confirmed state when user modifies the path
            if (this.value !== confirmedWorkingDirectory) {
                document.getElementById('working-directory-badge').classList.remove('show');
                document.getElementById('confirm-directory-btn').innerHTML = '<span>✓</span><span>Confirm</span>';
                this.style.borderColor = 'var(--border-color)';
            }
        });
        
        workingDirInput.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                navigateSuggestions(1);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                navigateSuggestions(-1);
            } else if (e.key === 'Enter') {
                if (currentSuggestionIndex >= 0 && currentSuggestionIndex < pathSuggestions.length) {
                    e.preventDefault();
                    selectSuggestion(pathSuggestions[currentSuggestionIndex]);
                }
            } else if (e.key === 'Escape') {
                hideAutocomplete();
            } else if (e.key === 'Tab' && pathSuggestions.length > 0) {
                e.preventDefault();
                if (currentSuggestionIndex < 0) {
                    currentSuggestionIndex = 0;
                }
                selectSuggestion(pathSuggestions[currentSuggestionIndex]);
            }
        });
        
        // Hide dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!workingDirInput.contains(e.target) && !autocompleteDropdown.contains(e.target)) {
                hideAutocomplete();
            }
        });
        
        function fetchPathSuggestions(path) {
            fetch('/list_directory', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ path: path })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.suggestions.length > 0) {
                    pathSuggestions = data.suggestions;
                    showSuggestions(data.suggestions);
                } else {
                    hideAutocomplete();
                }
            })
            .catch(error => {
                console.error('Error fetching path suggestions:', error);
                hideAutocomplete();
            });
        }
        
        function showSuggestions(suggestions) {
            autocompleteDropdown.innerHTML = '';
            currentSuggestionIndex = -1;
            
            suggestions.forEach((suggestion, index) => {
                const div = document.createElement('div');
                div.className = `path-suggestion ${suggestion.type}`;
                div.innerHTML = `
                    <span class="icon"></span>
                    <span class="name">${suggestion.display}</span>
                `;
                div.addEventListener('click', () => selectSuggestion(suggestion));
                div.addEventListener('mouseenter', () => {
                    currentSuggestionIndex = index;
                    updateSuggestionHighlight();
                });
                autocompleteDropdown.appendChild(div);
            });
            
            autocompleteDropdown.classList.add('show');
        }
        
        function hideAutocomplete() {
            autocompleteDropdown.classList.remove('show');
            pathSuggestions = [];
            currentSuggestionIndex = -1;
        }
        
        function navigateSuggestions(direction) {
            if (pathSuggestions.length === 0) return;
            
            currentSuggestionIndex += direction;
            if (currentSuggestionIndex < 0) {
                currentSuggestionIndex = pathSuggestions.length - 1;
            } else if (currentSuggestionIndex >= pathSuggestions.length) {
                currentSuggestionIndex = 0;
            }
            
            updateSuggestionHighlight();
        }
        
        function updateSuggestionHighlight() {
            const suggestions = autocompleteDropdown.querySelectorAll('.path-suggestion');
            suggestions.forEach((elem, index) => {
                if (index === currentSuggestionIndex) {
                    elem.classList.add('selected');
                    elem.scrollIntoView({ block: 'nearest' });
                } else {
                    elem.classList.remove('selected');
                }
            });
        }
        
        function selectSuggestion(suggestion) {
            workingDirInput.value = suggestion.path;
            hideAutocomplete();
            // Trigger new suggestions for subdirectories
            fetchPathSuggestions(suggestion.path);
        }
        
        // Global variable to store confirmed directory
        let confirmedWorkingDirectory = '';
        
        function confirmWorkingDirectory() {
            const dirPath = document.getElementById('working-directory').value.trim();
            if (!dirPath) {
                showDirectoryStatus('Please enter a directory path', 'error');
                return;
            }
            
            const confirmBtn = document.getElementById('confirm-directory-btn');
            confirmBtn.disabled = true;
            confirmBtn.innerHTML = '<span>⏳</span><span>Checking...</span>';
            
            fetch('/create_directory', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({directory: dirPath})
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    confirmedWorkingDirectory = data.directory;
                    showDirectoryStatus(`✓ Directory confirmed: ${data.directory}`, 'success');
                    document.getElementById('working-directory-badge').classList.add('show');
                    document.getElementById('working-directory').style.borderColor = '#10b981';
                    confirmBtn.innerHTML = '<span>✓</span><span>Confirmed</span>';
                    
                    // Flash success animation
                    const input = document.getElementById('working-directory');
                    input.style.transition = 'all 0.3s ease';
                    setTimeout(() => {
                        input.style.borderColor = 'var(--border-color)';
                    }, 2000);
                } else {
                    showDirectoryStatus(`✗ Error: ${data.error}`, 'error');
                    document.getElementById('working-directory').style.borderColor = '#ef4444';
                    confirmBtn.innerHTML = '<span>✗</span><span>Failed</span>';
                    
                    setTimeout(() => {
                        confirmBtn.innerHTML = '<span>✓</span><span>Confirm</span>';
                        document.getElementById('working-directory').style.borderColor = 'var(--border-color)';
                    }, 2000);
                }
            })
            .catch(error => {
                showDirectoryStatus(`✗ Network error: ${error.message}`, 'error');
                confirmBtn.innerHTML = '<span>✗</span><span>Error</span>';
                setTimeout(() => {
                    confirmBtn.innerHTML = '<span>✓</span><span>Confirm</span>';
                }, 2000);
            })
            .finally(() => {
                confirmBtn.disabled = false;
            });
        }
        
        function showDirectoryStatus(message, type) {
            const statusDiv = document.getElementById('working-directory-status');
            const statusIcon = statusDiv.querySelector('.status-icon');
            const statusText = statusDiv.querySelector('.status-text');
            
            statusDiv.className = `working-directory-status ${type} show`;
            
            if (type === 'success') {
                statusIcon.textContent = '✓';
            } else {
                statusIcon.textContent = '✗';
            }
            
            statusText.textContent = message;
            
            // Auto-hide after 5 seconds for success messages
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.classList.remove('show');
                }, 5000);
            }
        }
        
        function resetAllInputs() {
            
            // Reset primary vectors
            document.getElementById('pv-00').value = '';
            document.getElementById('pv-11').value = '';
            document.getElementById('pv-22').value = '';
            
            // Clear all basis positions
            clearAllBasisPositions();
            
            // Clear all crystal elements
            clearAllCrystalElements();
            
            // Reset grid vectors to default
            document.getElementById('gv-00').value = '2.1';
            document.getElementById('gv-11').value = '2.1';
            document.getElementById('gv-22').value = '2.1';
            
            // Reset box sizes
            document.getElementById('box-x').value = '10';
            document.getElementById('box-y').value = '20';
            document.getElementById('box-z').value = '10';
            
            // Reset lattice ranges
            document.getElementById('range-x-min').value = '0';
            document.getElementById('range-x-max').value = '10';
            document.getElementById('range-y-min').value = '0';
            document.getElementById('range-y-max').value = '20';
            document.getElementById('range-z-min').value = '5';
            document.getElementById('range-z-max').value = '6';
            
            // Reset ion configuration
            document.getElementById('ion-symbol').value = 'Ne';
            document.getElementById('ion-energy').value = '1000';
            document.getElementById('ion-dir-x').value = '0.0';
            document.getElementById('ion-dir-y').value = '0.0';
            document.getElementById('ion-dir-z').value = '-1.0';
            
            // Reset simulation parameters
            document.getElementById('repetitions').value = '1000';
            document.querySelector('input[name="irradiation-mode"][value="independent"]').checked = true;
            document.getElementById('seed').value = '42';
            document.getElementById('pmax').value = '1.45';
            document.getElementById('vacancy-recover').value = '1.3';
            document.getElementById('stop-energy').value = '0.1';
            document.getElementById('temperature').value = '0';
            document.getElementById('debye-temperature').value = '645';
            document.getElementById('dynamic-load').checked = false;
            document.getElementById('amorphous-mode').checked = false;
            document.getElementById('record-vacancy').checked = true;
            document.getElementById('record-penetration').checked = true;
            
            // Hide dynamic options
            document.getElementById('dynamic-options').classList.add('hidden');
            
            // Reset 3D viewer
            updateAtomCount();
            
            addOutput('All inputs have been reset to default values', 'success');
        }
        
        function getCrystalElements() {
            const elements = [];
            const elementRows = document.querySelectorAll('.element-row');
            
            elementRows.forEach(row => {
                const id = row.id.split('-')[1];
                const symbol = document.getElementById(`symbol-${id}`).value;
                const ed = parseFloat(document.getElementById(`ed-${id}`).value);
                const displacement = parseFloat(document.getElementById(`disp-${id}`).value);
                
                if (symbol && !isNaN(ed) && !isNaN(displacement)) {
                    elements.push({
                        symbol: symbol,
                        ed: ed,
                        displacement_energy: displacement
                    });
                }
            });
            
            return elements;
        }
        
        function getPrimaryVectors() {
            const matrix = [];
            for (let i = 0; i < 3; i++) {
                const row = [];
                for (let j = 0; j < 3; j++) {
                    const value = parseFloat(document.getElementById(`pv-${i}${j}`).value) || 0.0;
                    row.push(value);
                }
                matrix.push(row.join(' '));
            }
            return matrix.join('; ');
        }
        
        function getGridVectors() {
            const matrix = [];
            for (let i = 0; i < 3; i++) {
                const row = [];
                for (let j = 0; j < 3; j++) {
                    const value = parseFloat(document.getElementById(`gv-${i}${j}`).value) || 0.0;
                    row.push(value);
                }
                matrix.push(row.join(' '));
            }
            return matrix.join('; ');
        }
        
        function getBasisPositions() {
            const positions = [];
            const basisRows = document.querySelectorAll('.basis-row');
            
            basisRows.forEach(row => {
                const id = row.id.split('-')[1];
                const x = parseFloat(document.getElementById(`basis-x-${id}`).value) || 0.0;
                const y = parseFloat(document.getElementById(`basis-y-${id}`).value) || 0.0;
                const z = parseFloat(document.getElementById(`basis-z-${id}`).value) || 0.0;
                
                positions.push(`${x} ${y} ${z}`);
            });
            
            return positions.join('; ');
        }
        
        function getBasisTypes() {
            const types = [];
            const basisRows = document.querySelectorAll('.basis-row');
            
            basisRows.forEach(row => {
                const id = row.id.split('-')[1];
                const type = parseInt(document.getElementById(`basis-type-${id}`).value) || 1;
                types.push(type);
            });
            
            return types.join(', ');
        }
        
        function getBoxSizes() {
            const x = parseInt(document.getElementById('box-x').value) || 10;
            const y = parseInt(document.getElementById('box-y').value) || 10;
            const z = parseInt(document.getElementById('box-z').value) || 10;
            return `${x}, ${y}, ${z}`;
        }
        
        function getLatticeRanges() {
            const xMin = parseFloat(document.getElementById('range-x-min').value) || 0;
            const xMax = parseFloat(document.getElementById('range-x-max').value) || 10;
            const yMin = parseFloat(document.getElementById('range-y-min').value) || 0;
            const yMax = parseFloat(document.getElementById('range-y-max').value) || 10;
            const zMin = parseFloat(document.getElementById('range-z-min').value) || 0;
            const zMax = parseFloat(document.getElementById('range-z-max').value) || 10;
            return `${xMin} ${xMax}; ${yMin} ${yMax}; ${zMin} ${zMax}`;
        }
        
        function getPeriodic() {
            // Fixed periodic boundary: x=true, y=true, z=false
            return `true, true, false`;
        }
        
        
        function getIonDirection() {
            const x = parseFloat(document.getElementById('ion-dir-x').value) || 0.0;
            const y = parseFloat(document.getElementById('ion-dir-y').value) || 0.0;
            const z = parseFloat(document.getElementById('ion-dir-z').value) || -1.0;
            return [x, y, z];
        }
        
        function getIrradiationMode() {
            return document.querySelector('input[name="irradiation-mode"]:checked').value;
        }
        
        function getParameters() {
            const ionDir = getIonDirection();
            
            return {
                primary_vectors: getPrimaryVectors(),
                basis: getBasisPositions(),
                basis_types: getBasisTypes(),
                grid_vectors: getGridVectors(),
                crystal_elements: getCrystalElements(),
                box_sizes: getBoxSizes(),
                lattice_ranges: getLatticeRanges(),
                periodic: getPeriodic(),
                pmax: parseFloat(document.getElementById('pmax').value),
                vacancy_recover_distance: parseFloat(document.getElementById('vacancy-recover').value),
                stop_energy: parseFloat(document.getElementById('stop-energy').value),
                ion_symbol: document.getElementById('ion-symbol').value,
                ion_displacement_energy: 0.1,
                ion_energy: parseFloat(document.getElementById('ion-energy').value),
                ion_direction_x: ionDir[0],
                ion_direction_y: ionDir[1],
                ion_direction_z: ionDir[2],
                repetitions: parseInt(document.getElementById('repetitions').value),
                irradiation_mode: getIrradiationMode(),
                seed: parseInt(document.getElementById('seed').value),
                dynamic_load: document.getElementById('dynamic-load').checked,
                amorphous_mode: document.getElementById('amorphous-mode').checked,
                temperature: parseFloat(document.getElementById('temperature').value) || 0,
                debye_temperature: parseFloat(document.getElementById('debye-temperature').value) || 645,
                record_vacancy: document.getElementById('record-vacancy').checked,
                record_penetration: document.getElementById('record-penetration').checked,
                working_directory: confirmedWorkingDirectory || document.getElementById('working-directory').value.trim()
            };
        }
        
        function previewScript() {
            const params = getParameters();
            
            fetch('/run_simulation', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    parameters: params,
                    threads: 1,
                    preview_only: true
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.script) {
                    document.getElementById('script-preview-modal').textContent = data.script;
                    document.getElementById('scriptModal').style.display = 'block';
                }
            });
        }
        
        function closeScriptModal() {
            document.getElementById('scriptModal').style.display = 'none';
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('scriptModal');
            if (event.target == modal) {
                closeScriptModal();
            }
        }
        
        function runSimulation() {
            const mode = document.querySelector('input[name="input-mode"]:checked').value;
            let requestData = {};
            
            if (mode === 'parameters') {
                const params = getParameters();
                const crystalElements = getCrystalElements();
                
                const basisRows = document.querySelectorAll('.basis-row');
                if (!params.primary_vectors || params.primary_vectors === '0 0 0; 0 0 0; 0 0 0' || basisRows.length === 0 || crystalElements.length === 0) {
                    alert('Please fill in crystal structure (primary vectors, basis positions) and add at least one crystal element');
                    return;
                }
                
                requestData = {
                    parameters: params,
                    threads: 1
                };
            } else {
                const script = document.getElementById('julia-script').value;
                if (!script.trim()) {
                    alert('Please enter a Julia script');
                    return;
                }
                requestData = {
                    script: script,
                    threads: parseInt(document.getElementById('threads-script').value)
                };
            }
            
            // Disable run button, enable stop button
            document.getElementById('run-button').disabled = true;
            document.getElementById('stop-button').disabled = false;
            
            clearOutput();
            addOutput('Starting simulation...', 'success');
            
            fetch('/run_simulation', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentProcessId = data.process_id;
                    socket.emit('join_process', {process_id: currentProcessId});
                    addOutput(`Process started with ID: ${currentProcessId}`, 'success');
                    if (data.script && mode === 'parameters') {
                        document.getElementById('script-preview').textContent = data.script;
                    }
                } else {
                    addOutput(`Error: ${data.error}`, 'error');
                    document.getElementById('run-button').disabled = false;
                    document.getElementById('stop-button').disabled = true;
                }
            });
        }
        
        function stopSimulation() {
            if (currentProcessId) {
                fetch(`/stop_simulation/${currentProcessId}`, {
                    method: 'POST'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        addOutput('Simulation stopped', 'error');
                    }
                });
            }
        }
        
        function clearOutput() {
            document.getElementById('output').innerHTML = `
                <div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 40px; line-height: 1.6;">
                    <p>🚀 Click "Run Simulation" to start the DISPLATH simulation</p>
                    <p style="font-size: 14px; margin-top: 16px;">Real-time output from the Julia process will appear here.</p>
                </div>
            `;
        }
        
        function addOutput(text, className = '') {
            const output = document.getElementById('output');
            
            // Clear default content on first output
            if (output.innerHTML.includes('Click "Run Simulation"')) {
                output.innerHTML = '';
            }
            
            const line = document.createElement('div');
            line.className = 'output-line ' + className;
            line.textContent = text;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }
        
        // Socket.IO event handlers
        socket.on('output', function(data) {
            if (data.process_id === currentProcessId) {
                addOutput(data.data);
            }
        });
        
        socket.on('process_finished', function(data) {
            if (data.process_id === currentProcessId) {
                addOutput('Simulation finished', 'success');
                document.getElementById('run-button').disabled = false;
                document.getElementById('stop-button').disabled = true;
                currentProcessId = null;
            }
        });
    </script>
</body>
</html>